"use strict";
/*!
 * jsx-template-engine
 *
 * Copyright(c) 2021 Imed Jaberi
 * MIT Licensed
 */
'use-strict';
/*!
 * jsx-template-engine
 *
 * Copyright(c) 2021 Imed Jaberi
 * MIT Licensed
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Module dependencies.
 */
const vm_1 = __importDefault(require("vm"));
const jsx_1 = __importDefault(require("./jsx"));
const fs_1 = require("fs");
const core_1 = require("@babel/core");
const path_1 = require("path");
/**
 * Constants.
 *
 * @api private
 */
const BABEL_OPTIONS = {
    plugins: [
        "@babel/plugin-transform-modules-commonjs",
        [
            "@babel/plugin-transform-react-jsx",
            {
                pragma: "jsx",
                pragmaFrag: "jsx.Fragment"
            }
        ]
    ]
};
/**
 * a helper fuction to check any value is function.
 *
 * @api private
 */
function isFunction(value) {
    return typeof value === 'function';
}
/**
 * require handler used with the vm.
 *
 * @api private
 */
const vmRequire = (rootPath) => (filePath) => {
    var _a;
    // merge all paths to one.
    const path = (0, path_1.join)(rootPath, filePath);
    // read the code file.
    const code = importComponent(path);
    // transformed code with babel.
    const babelCode = (_a = (0, core_1.transformSync)(code, BABEL_OPTIONS)) === null || _a === void 0 ? void 0 : _a.code;
    // use the vm module to execute the babelcode.
    const context = vmRuntime(babelCode || '', path);
    // return all exports from the context.
    return context.module.exports;
};
/**
 * use the runtime behave with V8 Virtual Machine something like `eval()` function.
 *
 * @api private
 */
function vmRuntime(code, path) {
    const vmModule = { exports: {} };
    const vmContext = vm_1.default.createContext({
        jsx: jsx_1.default,
        module: vmModule,
        exports: vmModule.exports,
        require: path
            ? vmRequire((0, path_1.dirname)(path))
            : () => void 1
    });
    vm_1.default.runInContext(code, vmContext);
    return vmContext;
}
/**
 * the core of the agnostic jsx template engine (render to string).
 *
 * @api public
 */
async function jsxEngine(code, payload = {}, path) {
    var _a, _b, _c, _d;
    // execute the babel transform to compile the passed code.
    const babelCode = (_a = (await (0, core_1.transform)(code, BABEL_OPTIONS))) === null || _a === void 0 ? void 0 : _a.code;
    // get the vm runtime context.
    const context = vmRuntime(babelCode || '', path);
    // extract the jsx functional component from module.
    const func = (isFunction((_b = context === null || context === void 0 ? void 0 : context.module) === null || _b === void 0 ? void 0 : _b.exports)
        ? context.module.exports
        : (((_c = context === null || context === void 0 ? void 0 : context.exports) === null || _c === void 0 ? void 0 : _c.__esModule) === true &&
            isFunction((_d = context === null || context === void 0 ? void 0 : context.exports) === null || _d === void 0 ? void 0 : _d.default) &&
            context.exports.default));
    // use our custom pragma render method.
    const html = jsx_1.default.render(func(payload));
    return html;
}
/**
 * a jsx component (file) reader.
 *
 * @api public
 */
function importComponent(path) {
    // resolve the dot-env file path.
    const filePath = (0, path_1.resolve)(process.cwd(), path);
    // extract the file content.
    const fileContent = (0, fs_1.readFileSync)(filePath, { encoding: "utf8" }).toString();
    // return the content
    return fileContent;
}
__exportStar(require("./jsx"), exports);
exports.default = { render: jsxEngine, jsxEngine, importComponent };
module.exports = { render: jsxEngine, jsxEngine, importComponent };
